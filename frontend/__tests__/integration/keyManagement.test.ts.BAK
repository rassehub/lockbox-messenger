/**
 * Integration tests for Key Management System
 * Tests the complete flow from client to server
 * 
 * Run with: npm test -- keyManagement.integration.test.ts
 */

import { KeyManager } from '../../services/encryption/keyManager';
import KeyService from '../../services/encryption/keyService';
import { SignalProtocolManager } from '../../services/encryption/SignalProtocolManager';

// Mock fetch for server communication
global.fetch = jest.fn();

describe('Key Management Integration', () => {
  let keyManager: KeyManager;
  let signalManager: SignalProtocolManager;
  const userId = 'integration-test-user';
  const sessionCookie = 'session=integration-test-cookie';

  beforeEach(async () => {
    jest.clearAllMocks();
    
    // Create fresh instances
    signalManager = SignalProtocolManager.createTestInstance();
    keyManager = new KeyManager(userId);

    // Reset state
    SignalProtocolManager.resetInstance();
  });

  afterEach(() => {
    SignalProtocolManager.resetInstance();
  });

  describe('New User Registration Flow', () => {
    it('should generate keys locally and upload to server', async () => {
      // Mock successful server upload
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          success: true,
          message: 'Key bundle uploaded successfully'
        })
      });

      // Initialize as new user
      await keyManager.initializeForNewUser(sessionCookie);

      // Verify upload was called
      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('/keys/upload'),
        expect.objectContaining({
          method: 'POST',
          headers: expect.objectContaining({
            'Content-Type': 'application/json',
            'Cookie': sessionCookie
          }),
          body: expect.stringContaining('"registrationId"')
        })
      );

      // Verify key bundle structure
      const uploadCall = (global.fetch as jest.Mock).mock.calls[0];
      const body = JSON.parse(uploadCall[1].body);
      
      expect(body.keyBundle).toMatchObject({
        registrationId: expect.any(Number),
        identityPubKey: expect.any(String),
        signedPreKey: {
          keyId: expect.any(Number),
          publicKey: expect.any(String),
          signature: expect.any(String)
        },
        oneTimePreKeys: expect.arrayContaining([
          expect.objectContaining({
            keyId: expect.any(Number),
            publicKey: expect.any(String)
          })
        ])
      });

      // Should have at least 1 one-time pre-key (test mode generates 1, production generates 100)
      expect(body.keyBundle.oneTimePreKeys.length).toBeGreaterThanOrEqual(1);
    });

    it('should handle server upload failure gracefully', async () => {
      // Mock server error
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: false,
        json: async () => ({
          error: 'Server error'
        })
      });

      await expect(keyManager.initializeForNewUser(sessionCookie))
        .rejects.toThrow('Server error');
    });
  });

  describe('Existing User Login Flow', () => {
    it('should initialize without uploading keys', async () => {
      // Mock the checkPreKeys call that happens during initialization
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          success: true,
          needsMorePreKeys: false,
          availableCount: 50,
          threshold: 10
        })
      });

      await keyManager.initializeForExistingUser(sessionCookie);

      // Should only call check-prekeys endpoint, not upload
      expect(global.fetch).toHaveBeenCalledTimes(1);
      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('/keys/check-prekeys'),
        expect.any(Object)
      );
    });
  });

  describe('Message Encryption Flow', () => {
    const recipientId = 'recipient-user-123';

    beforeEach(async () => {
      // Mock successful initialization
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ success: true })
      });

      await keyManager.initializeForNewUser(sessionCookie);
      jest.clearAllMocks();
    });

    it('should fetch recipient keys and establish session on first message', async () => {
      const message = 'Hello, this is a test message!';

      // Generate real recipient keys
      const recipientSignalManager = SignalProtocolManager.createTestInstance();
      await recipientSignalManager.initialize(recipientId);
      const recipientKeys = await recipientSignalManager.getKeyBundle();

      // Mock fetching recipient's key bundle with real keys
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          success: true,
          keyBundle: {
            registrationId: recipientKeys.registrationId,
            identityPubKey: Buffer.from(recipientKeys.identityPubKey).toString('base64'),
            signedPreKey: {
              keyId: recipientKeys.signedPreKey.keyId,
              publicKey: Buffer.from(recipientKeys.signedPreKey.publicKey).toString('base64'),
              signature: Buffer.from(recipientKeys.signedPreKey.signature).toString('base64')
            },
            oneTimePreKeys: recipientKeys.oneTimePreKeys.map(key => ({
              keyId: key.keyId,
              publicKey: Buffer.from(key.publicKey).toString('base64')
            }))
          }
        })
      });

      const encrypted = await keyManager.encryptMessage(recipientId, message);

      // Verify key bundle fetch
      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining(`/keys/${recipientId}`),
        expect.objectContaining({
          method: 'GET',
          headers: expect.objectContaining({
            'Cookie': sessionCookie
          })
        })
      );

      // Verify encryption result
      expect(encrypted).toBeDefined();
      expect(encrypted.body).toBeDefined();
      expect(encrypted.type).toBeDefined();
    });

    it('should skip key fetch if session already exists', async () => {
      const message = 'Second message';

      // First, establish a session with real keys
      const recipientSignalManager = SignalProtocolManager.createTestInstance();
      await recipientSignalManager.initialize(recipientId);
      const recipientKeys = await recipientSignalManager.getKeyBundle();

      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          success: true,
          keyBundle: {
            registrationId: recipientKeys.registrationId,
            identityPubKey: Buffer.from(recipientKeys.identityPubKey).toString('base64'),
            signedPreKey: {
              keyId: recipientKeys.signedPreKey.keyId,
              publicKey: Buffer.from(recipientKeys.signedPreKey.publicKey).toString('base64'),
              signature: Buffer.from(recipientKeys.signedPreKey.signature).toString('base64')
            },
            oneTimePreKeys: recipientKeys.oneTimePreKeys.map(key => ({
              keyId: key.keyId,
              publicKey: Buffer.from(key.publicKey).toString('base64')
            }))
          }
        })
      });

      await keyManager.encryptMessage(recipientId, 'First message');
      jest.clearAllMocks();

      // Second message should not fetch keys
      const encrypted = await keyManager.encryptMessage(recipientId, message);

      expect(global.fetch).not.toHaveBeenCalled();
      expect(encrypted).toBeDefined();
    });
  });

  describe('Key Maintenance Flow', () => {
    beforeEach(async () => {
      // Initialize user - upload mock
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ success: true })
      });

      // Mock the checkPreKeys that happens after initialization
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          success: true,
          needsMorePreKeys: false,
          availableCount: 50,
          threshold: 10
        })
      });

      await keyManager.initializeForNewUser(sessionCookie);
      jest.clearAllMocks();
    });

    it('should check pre-keys and replenish if needed', async () => {
      // Mock check response showing low keys
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          success: true,
          needsMorePreKeys: true,
          availableCount: 5,
          threshold: 10
        })
      });

      // Mock successful key addition
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          success: true,
          message: 'Added 50 pre-keys',
          availableCount: 55
        })
      });

      // Mock getKeyStatistics for rotation check
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          success: true,
          stats: {
            totalPreKeys: 100,
            availablePreKeys: 55,
            consumedPreKeys: 45,
            lastUpdated: new Date()
          }
        })
      });

      await keyManager.maintainKeys();

      // Should check keys, add new ones, and check stats
      expect(global.fetch).toHaveBeenCalledTimes(3);
      
      // Check pre-keys
      expect(global.fetch).toHaveBeenNthCalledWith(
        1,
        expect.stringContaining('/keys/check-prekeys'),
        expect.objectContaining({ method: 'GET' })
      );

      // Add new keys
      expect(global.fetch).toHaveBeenNthCalledWith(
        2,
        expect.stringContaining('/keys/add-prekeys'),
        expect.objectContaining({
          method: 'POST',
          body: expect.stringContaining('"preKeys"')
        })
      );

      // Get stats for rotation check
      expect(global.fetch).toHaveBeenNthCalledWith(
        3,
        expect.stringContaining('/keys/stats/me'),
        expect.any(Object)
      );

      // Verify new keys structure
      const addCall = (global.fetch as jest.Mock).mock.calls[1];
      const body = JSON.parse(addCall[1].body);
      expect(body.preKeys).toHaveLength(50);
      expect(body.preKeys[0]).toMatchObject({
        keyId: expect.any(Number),
        publicKey: expect.any(String)
      });
    });

    it('should not replenish if keys are sufficient', async () => {
      // Mock check response showing enough keys
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          success: true,
          needsMorePreKeys: false,
          availableCount: 75,
          threshold: 10
        })
      });

      // Mock getKeyStatistics for rotation check
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          success: true,
          stats: {
            totalPreKeys: 100,
            availablePreKeys: 75,
            consumedPreKeys: 25,
            lastUpdated: new Date()
          }
        })
      });

      await keyManager.maintainKeys();

      // Should check and get stats, but not add keys
      expect(global.fetch).toHaveBeenCalledTimes(2);
      expect(global.fetch).toHaveBeenNthCalledWith(
        1,
        expect.stringContaining('/keys/check-prekeys'),
        expect.any(Object)
      );
      expect(global.fetch).toHaveBeenNthCalledWith(
        2,
        expect.stringContaining('/keys/stats/me'),
        expect.any(Object)
      );
    });
  });

  describe('Key Statistics', () => {
    beforeEach(async () => {
      // Mock upload for initialization
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ success: true })
      });

      // Mock checkPreKeys that happens after initialization
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          success: true,
          needsMorePreKeys: false,
          availableCount: 50,
          threshold: 10
        })
      });

      await keyManager.initializeForNewUser(sessionCookie);
      jest.clearAllMocks();
    });

    it('should fetch and return key statistics', async () => {
      const mockStats = {
        totalPreKeys: 100,
        availablePreKeys: 45,
        consumedPreKeys: 55,
        lastUpdated: new Date('2025-11-20T10:00:00Z')
      };

      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          success: true,
          stats: mockStats
        })
      });

      const stats = await keyManager.getKeyStatistics();

      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('/keys/stats/me'),
        expect.objectContaining({
          method: 'GET'
        })
      );

      expect(stats).toMatchObject({
        totalPreKeys: 100,
        availablePreKeys: 45,
        consumedPreKeys: 55
      });
    });
  });

  describe('End-to-End Encryption Flow', () => {
    it('should encrypt and decrypt messages between two users', async () => {
      const alice = new KeyManager('alice');
      const bob = new KeyManager('bob');

      // Initialize Alice - upload mock
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ success: true })
      });
      // Initialize Alice - checkPreKeys mock
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          success: true,
          needsMorePreKeys: false,
          availableCount: 50,
          threshold: 10
        })
      });
      await alice.initializeForNewUser('session=alice');

      // Initialize Bob - upload mock
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ success: true })
      });
      // Initialize Bob - checkPreKeys mock
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          success: true,
          needsMorePreKeys: false,
          availableCount: 50,
          threshold: 10
        })
      });
      await bob.initializeForNewUser('session=bob');

      jest.clearAllMocks();

      // Alice sends message to Bob
      const originalMessage = 'Hello Bob!';

      // Mock fetching Bob's keys
      const bobSignalManager = SignalProtocolManager.createTestInstance();
      await bobSignalManager.initialize('bob');
      const bobKeys = await bobSignalManager.getKeyBundle();

      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          success: true,
          keyBundle: {
            registrationId: bobKeys.registrationId,
            identityPubKey: Buffer.from(bobKeys.identityPubKey).toString('base64'),
            signedPreKey: {
              keyId: bobKeys.signedPreKey.keyId,
              publicKey: Buffer.from(bobKeys.signedPreKey.publicKey).toString('base64'),
              signature: Buffer.from(bobKeys.signedPreKey.signature).toString('base64')
            },
            oneTimePreKeys: bobKeys.oneTimePreKeys.map(key => ({
              keyId: key.keyId,
              publicKey: Buffer.from(key.publicKey).toString('base64')
            }))
          }
        })
      });

      const encrypted = await alice.encryptMessage('bob', originalMessage);

      // Bob decrypts message from Alice
      const decrypted = await bob.decryptMessage('alice', encrypted);

      expect(decrypted).toBe(originalMessage);
    });
  });

  describe('Error Handling', () => {
    it('should handle network errors during key check', async () => {
      // Mock checkPreKeys failure during initialization
      (global.fetch as jest.Mock).mockRejectedValueOnce(new Error('Network error'));

      await expect(keyManager.initializeForExistingUser(sessionCookie))
        .rejects.toThrow('Network error');
    });

    it('should handle upload failures', async () => {
      // Mock upload failure (this is the first call in initializeForNewUser)
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: false,
        json: async () => ({
          error: 'Invalid key format'
        })
      });

      await expect(keyManager.initializeForNewUser(sessionCookie))
        .rejects.toThrow('Invalid key format');
    });

    it('should handle missing recipient keys', async () => {
      // Initialize first
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ success: true })
      });
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          success: true,
          needsMorePreKeys: false,
          availableCount: 50,
          threshold: 10
        })
      });
      await keyManager.initializeForNewUser(sessionCookie);
      jest.clearAllMocks();

      // Mock missing recipient - should fail during getKeyBundle
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: false,
        json: async () => ({
          error: 'User not found'
        })
      });

      await expect(keyManager.encryptMessage('nonexistent-user', 'Hello'))
        .rejects.toThrow('User not found');
    });
  });
});
